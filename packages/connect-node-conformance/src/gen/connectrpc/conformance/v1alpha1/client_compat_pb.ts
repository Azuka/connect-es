// Copyright 2023 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.3 with parameter "ts_nocheck=false,target=ts"
// @generated from file connectrpc/conformance/v1alpha1/client_compat.proto (package connectrpc.conformance.v1alpha1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, Struct } from "@bufbuild/protobuf";
import { Codec, Compression, HTTPVersion, Protocol, StreamType } from "./config_pb.js";
import { ConformancePayload, Error, Header } from "./service_pb.js";

/**
 * Describes one call the client should make. The client reads
 * these from stdin and, for each one, invokes an RPC as directed
 * and writes the results (in the form of a ClientCompatResponse
 * message) to stdout.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientCompatRequest
 */
export class ClientCompatRequest extends Message<ClientCompatRequest> {
  /**
   * @generated from field: string test_name = 1;
   */
  testName = "";

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.HTTPVersion http_version = 2;
   */
  httpVersion = HTTPVersion.HTTP_VERSION_UNSPECIFIED;

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.Protocol protocol = 3;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.Codec codec = 4;
   */
  codec = Codec.UNSPECIFIED;

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.Compression compression = 5;
   */
  compression = Compression.UNSPECIFIED;

  /**
   * @generated from field: string host = 6;
   */
  host = "";

  /**
   * @generated from field: uint32 port = 7;
   */
  port = 0;

  /**
   * If non-empty, the server is using TLS. The bytes are the
   * server's PEM-encoded certificate, which the client should
   * verify and trust.
   *
   * @generated from field: bytes server_tls_cert = 8;
   */
  serverTlsCert = new Uint8Array(0);

  /**
   * If present, the client certificate credentials to use to
   * authenticate with the server. This will only be present
   * when server_tls_cert is non-empty.
   *
   * @generated from field: connectrpc.conformance.v1alpha1.ClientCompatRequest.TLSCreds client_tls_creds = 9;
   */
  clientTlsCreds?: ClientCompatRequest_TLSCreds;

  /**
   * If non-zero, indicates the maximum size in bytes for a message.
   * If the server sends anything larger, the client should reject it.
   *
   * @generated from field: uint32 message_receive_limit = 10;
   */
  messageReceiveLimit = 0;

  /**
   * @generated from field: string service = 11;
   */
  service = "";

  /**
   * @generated from field: string method = 12;
   */
  method = "";

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.StreamType stream_type = 13;
   */
  streamType = StreamType.UNSPECIFIED;

  /**
   * If protocol indicates Connect and stream type indicates
   * Unary, this instructs the client to use a GET HTTP method
   * when making the request.
   *
   * @generated from field: bool use_get_http_method = 14;
   */
  useGetHttpMethod = false;

  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.Header request_headers = 15;
   */
  requestHeaders: Header[] = [];

  /**
   * There will be exactly one for unary and server-stream methods.
   * For client- and bidi-stream methods, all entries will have the
   * same type URL (which matches the request type of the method).
   *
   * @generated from field: repeated google.protobuf.Any request_messages = 16;
   */
  requestMessages: Any[] = [];

  /**
   * @generated from field: optional uint32 timeout_ms = 17;
   */
  timeoutMs?: number;

  /**
   * Wait this many milliseconds before sending a request message.
   * For client- or bidi-streaming requests, this delay should be
   * applied before each request sent.
   *
   * @generated from field: uint32 request_delay_ms = 18;
   */
  requestDelayMs = 0;

  constructor(data?: PartialMessage<ClientCompatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientCompatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "http_version", kind: "enum", T: proto3.getEnumType(HTTPVersion) },
    { no: 3, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 4, name: "codec", kind: "enum", T: proto3.getEnumType(Codec) },
    { no: 5, name: "compression", kind: "enum", T: proto3.getEnumType(Compression) },
    { no: 6, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "server_tls_cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "client_tls_creds", kind: "message", T: ClientCompatRequest_TLSCreds },
    { no: 10, name: "message_receive_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "stream_type", kind: "enum", T: proto3.getEnumType(StreamType) },
    { no: 14, name: "use_get_http_method", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "request_headers", kind: "message", T: Header, repeated: true },
    { no: 16, name: "request_messages", kind: "message", T: Any, repeated: true },
    { no: 17, name: "timeout_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 18, name: "request_delay_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCompatRequest {
    return new ClientCompatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCompatRequest {
    return new ClientCompatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCompatRequest {
    return new ClientCompatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCompatRequest | PlainMessage<ClientCompatRequest> | undefined, b: ClientCompatRequest | PlainMessage<ClientCompatRequest> | undefined): boolean {
    return proto3.util.equals(ClientCompatRequest, a, b);
  }
}

/**
 * @generated from message connectrpc.conformance.v1alpha1.ClientCompatRequest.TLSCreds
 */
export class ClientCompatRequest_TLSCreds extends Message<ClientCompatRequest_TLSCreds> {
  /**
   * @generated from field: bytes cert = 1;
   */
  cert = new Uint8Array(0);

  /**
   * @generated from field: bytes key = 2;
   */
  key = new Uint8Array(0);

  constructor(data?: PartialMessage<ClientCompatRequest_TLSCreds>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientCompatRequest.TLSCreds";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCompatRequest_TLSCreds {
    return new ClientCompatRequest_TLSCreds().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCompatRequest_TLSCreds {
    return new ClientCompatRequest_TLSCreds().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCompatRequest_TLSCreds {
    return new ClientCompatRequest_TLSCreds().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCompatRequest_TLSCreds | PlainMessage<ClientCompatRequest_TLSCreds> | undefined, b: ClientCompatRequest_TLSCreds | PlainMessage<ClientCompatRequest_TLSCreds> | undefined): boolean {
    return proto3.util.equals(ClientCompatRequest_TLSCreds, a, b);
  }
}

/**
 * The outcome of one ClientCompatRequest.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientCompatResponse
 */
export class ClientCompatResponse extends Message<ClientCompatResponse> {
  /**
   * @generated from field: string test_name = 1;
   */
  testName = "";

  /**
   * @generated from oneof connectrpc.conformance.v1alpha1.ClientCompatResponse.result
   */
  result: {
    /**
     * @generated from field: connectrpc.conformance.v1alpha1.ClientResponseResult response = 2;
     */
    value: ClientResponseResult;
    case: "response";
  } | {
    /**
     * @generated from field: connectrpc.conformance.v1alpha1.ClientErrorResult error = 3;
     */
    value: ClientErrorResult;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * This field is used only by the reference client, and it can be used
   * to provide additional feedback about problems observed in the server
   * response. If non-empty, the test case is considered failed even if
   * the result above matches all expectations.
   *
   * @generated from field: repeated string feedback = 4;
   */
  feedback: string[] = [];

  constructor(data?: PartialMessage<ClientCompatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientCompatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "response", kind: "message", T: ClientResponseResult, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: ClientErrorResult, oneof: "result" },
    { no: 4, name: "feedback", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCompatResponse {
    return new ClientCompatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCompatResponse {
    return new ClientCompatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCompatResponse {
    return new ClientCompatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCompatResponse | PlainMessage<ClientCompatResponse> | undefined, b: ClientCompatResponse | PlainMessage<ClientCompatResponse> | undefined): boolean {
    return proto3.util.equals(ClientCompatResponse, a, b);
  }
}

/**
 * The result of a ClientCompatRequest, which may or may bot be successful.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientResponseResult
 */
export class ClientResponseResult extends Message<ClientResponseResult> {
  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.Header response_headers = 1;
   */
  responseHeaders: Header[] = [];

  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.ConformancePayload payloads = 2;
   */
  payloads: ConformancePayload[] = [];

  /**
   * The error received from the actual RPC invocation. Note this is not representative
   * of a runtime error and should always be the proto equivalent of a Connect error.
   *
   * @generated from field: connectrpc.conformance.v1alpha1.Error error = 3;
   */
  error?: Error;

  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.Header response_trailers = 4;
   */
  responseTrailers: Header[] = [];

  /**
   * When processing an error from a Connect server, this should contain
   * the actual JSON received on the wire. Clients under test do not need
   * to populate this field. It is primarily used by the reference client,
   * so that a server-under-test's on-the-wire error can be examined and
   * validated.
   *
   * TODO - We should probably add a field to indicate the number of messages that were
   * in the test case request definition but that couldn't be sent, due to an error
   * occurring before finishing the upload.
   *
   * @generated from field: google.protobuf.Struct connect_error_raw = 5;
   */
  connectErrorRaw?: Struct;

  constructor(data?: PartialMessage<ClientResponseResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientResponseResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response_headers", kind: "message", T: Header, repeated: true },
    { no: 2, name: "payloads", kind: "message", T: ConformancePayload, repeated: true },
    { no: 3, name: "error", kind: "message", T: Error },
    { no: 4, name: "response_trailers", kind: "message", T: Header, repeated: true },
    { no: 5, name: "connect_error_raw", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientResponseResult {
    return new ClientResponseResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientResponseResult {
    return new ClientResponseResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientResponseResult {
    return new ClientResponseResult().fromJsonString(jsonString, options);
  }

  static equals(a: ClientResponseResult | PlainMessage<ClientResponseResult> | undefined, b: ClientResponseResult | PlainMessage<ClientResponseResult> | undefined): boolean {
    return proto3.util.equals(ClientResponseResult, a, b);
  }
}

/**
 * The client is not able to fulfill the ClientCompatRequest. This may be due
 * to a runtime error or an unexpected internal error such as the requested protocol
 * not being supported. This is completely independent of the actual RPC invocation.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientErrorResult
 */
export class ClientErrorResult extends Message<ClientErrorResult> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<ClientErrorResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientErrorResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientErrorResult {
    return new ClientErrorResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientErrorResult {
    return new ClientErrorResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientErrorResult {
    return new ClientErrorResult().fromJsonString(jsonString, options);
  }

  static equals(a: ClientErrorResult | PlainMessage<ClientErrorResult> | undefined, b: ClientErrorResult | PlainMessage<ClientErrorResult> | undefined): boolean {
    return proto3.util.equals(ClientErrorResult, a, b);
  }
}

