// Copyright 2023 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.3 with parameter "ts_nocheck=false,target=ts"
// @generated from file connectrpc/conformance/v1alpha1/client_compat.proto (package connectrpc.conformance.v1alpha1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, Struct } from "@bufbuild/protobuf";
import { Codec, Compression, HTTPVersion, Protocol, StreamType } from "./config_pb.js";
import { ConformancePayload, Error, Header } from "./service_pb.js";

/**
 * Describes one call the client should make. The client reads
 * these from stdin and, for each one, invokes an RPC as directed
 * and writes the results (in the form of a ClientCompatResponse
 * message) to stdout.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientCompatRequest
 */
export class ClientCompatRequest extends Message<ClientCompatRequest> {
  /**
   * @generated from field: string test_name = 1;
   */
  testName = "";

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.HTTPVersion http_version = 2;
   */
  httpVersion = HTTPVersion.HTTP_VERSION_UNSPECIFIED;

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.Protocol protocol = 3;
   */
  protocol = Protocol.UNSPECIFIED;

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.Codec codec = 4;
   */
  codec = Codec.UNSPECIFIED;

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.Compression compression = 5;
   */
  compression = Compression.UNSPECIFIED;

  /**
   * @generated from field: string host = 6;
   */
  host = "";

  /**
   * @generated from field: uint32 port = 7;
   */
  port = 0;

  /**
   * If non-empty, the server is using TLS. The bytes are the
   * server's PEM-encoded certificate, which the client should
   * verify and trust.
   *
   * @generated from field: bytes server_tls_cert = 8;
   */
  serverTlsCert = new Uint8Array(0);

  /**
   * @generated from field: string service = 9;
   */
  service = "";

  /**
   * @generated from field: string method = 10;
   */
  method = "";

  /**
   * @generated from field: connectrpc.conformance.v1alpha1.StreamType stream_type = 11;
   */
  streamType = StreamType.UNSPECIFIED;

  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.Header request_headers = 12;
   */
  requestHeaders: Header[] = [];

  /**
   * There will be exactly one for unary and server-stream methods.
   * For client- and bidi-stream methods, all entries will have the
   * same type URL (which matches the request type of the method).
   *
   * @generated from field: repeated google.protobuf.Any request_messages = 13;
   */
  requestMessages: Any[] = [];

  /**
   * @generated from field: optional uint32 timeout_ms = 14;
   */
  timeoutMs?: number;

  /**
   * wait this many milliseconds before sending a request message
   * TODO - This could potentially be removed bc this is in the relevant requests
   * in the request_messages field
   *
   * @generated from field: uint32 response_delay_ms = 15;
   */
  responseDelayMs = 0;

  /**
   * Tells the server whether it should wait for each request
   * before sending a response.
   * If true, it indicates the server should effectively interleave the
   * stream so messages are sent in request->response pairs.
   * If false, then the response stream will be sent once all request messages
   * are finished sending with the only delays between messages
   * being the optional fixed milliseconds defined in the response
   * definition.
   * This field is only relevant in the first message in the stream
   * and should be ignored in subsequent messages.
   * Note, this is only applicable to bidi endpoints.
   * TODO - This could potentially be removed bc this is in the BidiStreamRequest
   * which would be in the request_messages field
   *
   * @generated from field: bool full_duplex = 16;
   */
  fullDuplex = false;

  constructor(data?: PartialMessage<ClientCompatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientCompatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "http_version", kind: "enum", T: proto3.getEnumType(HTTPVersion) },
    { no: 3, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) },
    { no: 4, name: "codec", kind: "enum", T: proto3.getEnumType(Codec) },
    { no: 5, name: "compression", kind: "enum", T: proto3.getEnumType(Compression) },
    { no: 6, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "server_tls_cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "stream_type", kind: "enum", T: proto3.getEnumType(StreamType) },
    { no: 12, name: "request_headers", kind: "message", T: Header, repeated: true },
    { no: 13, name: "request_messages", kind: "message", T: Any, repeated: true },
    { no: 14, name: "timeout_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 15, name: "response_delay_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 16, name: "full_duplex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCompatRequest {
    return new ClientCompatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCompatRequest {
    return new ClientCompatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCompatRequest {
    return new ClientCompatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCompatRequest | PlainMessage<ClientCompatRequest> | undefined, b: ClientCompatRequest | PlainMessage<ClientCompatRequest> | undefined): boolean {
    return proto3.util.equals(ClientCompatRequest, a, b);
  }
}

/**
 * The outcome of one ClientCompatRequest.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientCompatResponse
 */
export class ClientCompatResponse extends Message<ClientCompatResponse> {
  /**
   * @generated from field: string test_name = 1;
   */
  testName = "";

  /**
   * @generated from oneof connectrpc.conformance.v1alpha1.ClientCompatResponse.result
   */
  result: {
    /**
     * @generated from field: connectrpc.conformance.v1alpha1.ClientResponseResult response = 2;
     */
    value: ClientResponseResult;
    case: "response";
  } | {
    /**
     * @generated from field: connectrpc.conformance.v1alpha1.ClientErrorResult error = 3;
     */
    value: ClientErrorResult;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ClientCompatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientCompatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "response", kind: "message", T: ClientResponseResult, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: ClientErrorResult, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCompatResponse {
    return new ClientCompatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCompatResponse {
    return new ClientCompatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCompatResponse {
    return new ClientCompatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCompatResponse | PlainMessage<ClientCompatResponse> | undefined, b: ClientCompatResponse | PlainMessage<ClientCompatResponse> | undefined): boolean {
    return proto3.util.equals(ClientCompatResponse, a, b);
  }
}

/**
 * The result of a ClientCompatRequest, which may or may bot be successful.
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientResponseResult
 */
export class ClientResponseResult extends Message<ClientResponseResult> {
  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.Header response_headers = 1;
   */
  responseHeaders: Header[] = [];

  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.ConformancePayload payloads = 2;
   */
  payloads: ConformancePayload[] = [];

  /**
   * The error received from the actual RPC invocation. Note this is not representative
   * of a runtime error and should always be the proto equivalent of a Connect error
   *
   * @generated from field: connectrpc.conformance.v1alpha1.Error error = 3;
   */
  error?: Error;

  /**
   * In case the client cannot decode Any from JSON, it should instead return the received JSON
   *
   * @generated from field: repeated google.protobuf.Struct error_details_raw = 7;
   */
  errorDetailsRaw: Struct[] = [];

  /**
   * @generated from field: repeated connectrpc.conformance.v1alpha1.Header response_trailers = 4;
   */
  responseTrailers: Header[] = [];

  constructor(data?: PartialMessage<ClientResponseResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientResponseResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response_headers", kind: "message", T: Header, repeated: true },
    { no: 2, name: "payloads", kind: "message", T: ConformancePayload, repeated: true },
    { no: 3, name: "error", kind: "message", T: Error },
    { no: 7, name: "error_details_raw", kind: "message", T: Struct, repeated: true },
    { no: 4, name: "response_trailers", kind: "message", T: Header, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientResponseResult {
    return new ClientResponseResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientResponseResult {
    return new ClientResponseResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientResponseResult {
    return new ClientResponseResult().fromJsonString(jsonString, options);
  }

  static equals(a: ClientResponseResult | PlainMessage<ClientResponseResult> | undefined, b: ClientResponseResult | PlainMessage<ClientResponseResult> | undefined): boolean {
    return proto3.util.equals(ClientResponseResult, a, b);
  }
}

/**
 * The client is not able to fulfill the ClientCompatRequest. This may be due
 * to a runtime error or an unexpected internal error such as the requested protocol
 * not being supported. This is completely independent of the actual RPC invocation
 *
 * @generated from message connectrpc.conformance.v1alpha1.ClientErrorResult
 */
export class ClientErrorResult extends Message<ClientErrorResult> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<ClientErrorResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "connectrpc.conformance.v1alpha1.ClientErrorResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientErrorResult {
    return new ClientErrorResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientErrorResult {
    return new ClientErrorResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientErrorResult {
    return new ClientErrorResult().fromJsonString(jsonString, options);
  }

  static equals(a: ClientErrorResult | PlainMessage<ClientErrorResult> | undefined, b: ClientErrorResult | PlainMessage<ClientErrorResult> | undefined): boolean {
    return proto3.util.equals(ClientErrorResult, a, b);
  }
}

